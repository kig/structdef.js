<html>
<script src="DataStream.js"></script>
<script>
  function assert(b) {
    if (!b) {
      throw('assert failed');
    }
  };

  function assertEqual(a,b) {
    if (a != b) {
      throw('assertEqual failed: '+a+' != '+b);
    }
  };

  function assertNotEqual(a,b) {
    if (a == b) {
      throw('assertNotEqual failed: '+a+' == '+b);
    }
  };

  function assertFail(f) {
    var success = true;
    try { f(); success = false; } catch(e) { }
    if (!success) {
      throw('assertFail failed: '+f.toString());
    }
  };

  var testType = function(ds, t, elen) {
    var i = 0;
    var blen = ds.byteLength;
    ds.dynamicSize = true;
    ds.endianness = DataStream.LITTLE_ENDIAN;
    ds.seek(0);
    for (i=0; i<ds.byteLength/elen; i++) {
      ds["write"+t](125);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.seek(0);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(ds["read"+t](), 125);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.endianness = DataStream.BIG_ENDIAN;
    ds.seek(0);
    if (elen > 1) {
      for (i=0; i<ds.byteLength/elen; i++) {
        assertNotEqual(ds["read"+t](), 125);
      }
    }
    ds.seek(0);
    for (i=0; i<ds.byteLength/elen; i++) {
      ds["write"+t](125);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.seek(0);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(ds["read"+t](), 125);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    assertFail(function() {
      ds["read"+t]();
    });
    ds.dynamicSize = false;
    assertFail(function() {
      ds["write"+t](125);
    });
    testTypeArray(ds, t, elen);
  };

  var testTypeArray = function(ds, t, elen) {
    var i = 0;
    var blen = ds.byteLength;
    var arr = [];
    for (i=0; i<ds.byteLength/elen; i++) {
      arr.push(125);
    }
    ds.dynamicSize = true;
    ds.endianness = DataStream.LITTLE_ENDIAN;
    ds.seek(0);
    ds["write"+t+"Array"](arr);
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.seek(0);
    var rarr = ds["read"+t+"Array"](arr.length);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(rarr[i], arr[i]);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.seek(0);
    var rarr = ds["map"+t+"Array"](arr.length);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(rarr[i], arr[i]);
      rarr[i] = 127;
    }
    ds.seek(0);
    var warr = ds["read"+t+"Array"](arr.length);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(warr[i], 127);
    }
    ds.endianness = DataStream.BIG_ENDIAN;
    ds.seek(0);
    var rarr = ds["map"+t+"Array"](arr.length);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertNotEqual(rarr[i], arr[i]);
      rarr[i] = 127;
    }
    ds.seek(0);
    if (elen > 1) {
    var warr = ds["read"+t+"Array"](arr.length);
      for (i=0; i<ds.byteLength/elen; i++) {
        assertNotEqual(warr[i], 127);
      }
    }
    ds.seek(0);
    ds["map"+t+"Array"](arr.length);
    var warr = ds["read"+t+"Array"](arr.length);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(warr[i], 127);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.endianness = DataStream.BIG_ENDIAN;
    ds.seek(0);
    var rarr = ds["read"+t+"Array"](arr.length);
    if (elen > 1) {
      for (i=0; i<ds.byteLength/elen; i++) {
        assertNotEqual(rarr[i], arr[i]);
      }
    }
    ds.seek(0);
    ds["write"+t+"Array"](arr);
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    ds.seek(0);
    var rarr = ds["read"+t+"Array"](arr.length);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(rarr[i], arr[i]);
    }
    ds.seek(0);
    for (i=0; i<ds.byteLength/elen; i++) {
      assertEqual(ds["read"+t](), arr[i]);
    }
    assertEqual(ds.position , elen*i);
    assertEqual(ds.byteLength , blen);
    assertEqual(ds.buffer.byteLength , ds.byteLength);
    assertFail(function() {
      ds["read"+t+"Array"](1);
    });
    ds.dynamicSize = false;
    assertFail(function() {
      ds["write"+t+"Array"]([125]);
    });
    var ds2 = new DataStream();
    ds2["write"+t+"Array"](arr);
    ds2.seek(0);
    var rarr = ds2["read"+t+"Array"](arr.length);
    for (i=0; i<ds2.byteLength/elen; i++) {
      assertEqual(rarr[i], arr[i]);
    }
    ds2.buffer;
    assertFail(function() {
      ds2["read"+t+"Array"](1);
    });
  };

  var test_constructor = function() {
    var buf = new ArrayBuffer(100);
    var ds = new DataStream(buf);
    assertEqual(ds.byteLength, buf.byteLength);
    assertEqual(ds.endianness, DataStream.LITTLE_ENDIAN);
    for (var i=0; i<100; i++) {
      ds = new DataStream(buf, i);
      ds = new DataStream(buf, i, DataStream.BIG_ENDIAN);
      ds = new DataStream(buf, i, DataStream.LITTLE_ENDIAN);
      assertEqual(ds.byteLength, buf.byteLength-i);
      assertEqual(ds.byteOffset, i);
    }
    ds = new DataStream(buf, 2, DataStream.BIG_ENDIAN);
    assertEqual(ds.endianness, DataStream.BIG_ENDIAN);
    ds = new DataStream(buf, null, DataStream.BIG_ENDIAN);
    assertEqual(ds.endianness, DataStream.BIG_ENDIAN);
    assertEqual(ds.byteLength, buf.byteLength);
    ds = new DataStream(buf, null, DataStream.LITTLE_ENDIAN);
    assertEqual(ds.endianness, DataStream.LITTLE_ENDIAN);
    assertEqual(ds.byteLength, buf.byteLength);
    var dv = new DataView(buf);
    ds = new DataStream(dv, 0, DataStream.BIG_ENDIAN);
    assertEqual(ds.endianness, DataStream.BIG_ENDIAN);
    assertEqual(ds.byteLength, buf.byteLength);
    assertEqual(ds.byteOffset, dv.byteOffset);
    for (var i=0; i<100; i++) {
      dv = new DataView(buf, i);
      ds = new DataStream(dv);
      assertEqual(ds.byteLength, buf.byteLength-i);
      assertEqual(ds.byteOffset, dv.byteOffset);
    }
    for (var i=0; i<50; i++) {
      dv = new DataView(buf, 50);
      ds = new DataStream(dv, i);
      assertEqual(ds.byteLength, buf.byteLength-i-dv.byteOffset);
      assertEqual(ds.byteOffset, dv.byteOffset+i);
    }
    for (var i=0; i<100; i++) {
      dv = new Uint8Array(buf, i);
      ds = new DataStream(dv);
      assertEqual(ds.byteLength, buf.byteLength-i);
      assertEqual(ds.byteOffset, dv.byteOffset);
    }
    for (var i=0; i<50; i++) {
      dv = new Uint8Array(buf, 50);
      ds = new DataStream(dv, i);
      assertEqual(ds.byteLength, buf.byteLength-i-dv.byteOffset);
      assertEqual(ds.byteOffset, dv.byteOffset+i);
    }
    for (var i=0; i<25; i++) {
      dv = new Float32Array(buf, i*4);
      ds = new DataStream(dv);
      assertEqual(ds.byteLength, buf.byteLength-i*4);
      assertEqual(ds.byteOffset, dv.byteOffset);
    }
    for (var i=0; i<12; i++) {
      dv = new Float32Array(buf, 12);
      ds = new DataStream(dv, i);
      assertEqual(ds.byteLength, buf.byteLength-i-dv.byteOffset);
      assertEqual(ds.byteOffset, dv.byteOffset+i);
    }
  };

  test_constructor();

  var buf = new ArrayBuffer(1000);
  var ds = new DataStream(buf);
  assertEqual(ds.byteLength , buf.byteLength);
  for (var i = 0; i < 1000 / 8; i++) {
    ds.writeFloat64(0.125);
  }
  assertEqual(ds.position , buf.byteLength);
  assertEqual(ds.byteLength , buf.byteLength);
  assertEqual(ds.buffer.byteLength , buf.byteLength);

  ds.seek(0);
  for (var i = 0; i < 1000 / 8; i++) {
    assertEqual(0.125 , ds.readFloat64());
  }
  assertEqual(ds.position , buf.byteLength);

  assertFail(function() {
    ds.readFloat32();
  });

  ds.seek(0);
  ds.endianness = DataStream.BIG_ENDIAN;
  for (var i = 0; i < 1000 / 8; i++) {
    assertNotEqual(0.125, ds.readFloat64());
  }
  ds.seek(0);
  for (var i = 0; i < 999; i++) {
    ds.writeFloat32(0.125);
  }
  // reading beyond extended buffer succeeds for performance reasons
  ds.readFloat32();
  assertEqual(ds.position , 4000);
  assertEqual(ds.byteLength , 3996);
  assertEqual(ds.buffer.byteLength , 3996);
  ds.position = 3996;
  // but fails after getting buffer due to _trimAlloc
  assertFail(function() {
    ds.readFloat32();
  });

  ds.seek(0);
  for (var i = 0; i < 999; i++) {
    assertEqual(0.125 , ds.readFloat32());
  }
  assertEqual(ds.position , ds.buffer.byteLength);

  ds.writeFloat32(0.125);

  ds.dynamicSize = false;
  assertFail(function() {
    ds.writeFloat32(0.125);
  });

  assertEqual(ds.position , 4000);
  assertEqual(ds.byteLength , 4000);
  assertEqual(ds.buffer.byteLength , ds.position);

  testType(ds, 'Int32', 4);
  testType(ds, 'Int16', 2);
  testType(ds, 'Int8', 1);
  testType(ds, 'Uint32', 4);
  testType(ds, 'Uint16', 2);
  testType(ds, 'Uint8', 1);
  testType(ds, 'Float32', 4);
  testType(ds, 'Float64', 8);

  console.log('tests passed');

</script>
</html>